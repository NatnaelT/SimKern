SIM0/SIM1 how-to guide:


DISCLAIMER: This will only work when using the most up-to-date versions of our files from the GitHub
(updated 9/1/17 around 1pm)



1) Naive machine learning

After running SIM0 with your .t file, inside your GenomeFiles folder, there should be two files. Sim0Output.csv will
contain the responses for all genomes (integers). Sim0GenomesMatrix.csv contains all the genome variables in matrix
form (each line of values corresponds to a genome).

For the actual machine learning, we don’t have this automated yet, so I have been doing this in a separate script.
Here are the steps:

	a. Get the data from Sim0Output.csv into a list.
	
	b. Get the data from Sim0GenomesMatrix.csv into a list of lists (like a matrix)

	c. At the top of the script, you will need the following lines:
		from svm.svmRunner import runSVM
		from RandomForest.rfRunner import runRF
		import numpy

	d. Now what we want to do is run the SVM and Random Forest on this data with some % of it being used for training,
	   and the rest for testing. To get a sense of how well it’s doing on average, we will want to permute the data many
	   many times (I have been doing 10,000). Here is what that part of the script should look like:


results = [[], [], [], [], [], []]
which = insert_list_of_columns_of_matrix_to_use # COMMENT: For naive, you will want this list to be all genome variables

for i in range(0, insert_number_of_desired_permutations_of_data):

    pos = 0
    order = numpy.random.permutation(insert_number_of_genomes)
    newmatrix = []

    for j in order:

        newmatrix.append([])

        for k in which:

            newmatrix[pos].append(genomes_matrix[j][k])

        pos = pos+1

    newresponses = []

    for i in order:

        newresponses.append(response_list[i])

    [trAcSVM, teAcSVM, totAcSVM] = runSVM(newresponses, newmatrix, ”insert_kernel_type”, insert_decimal_for_how_much_training_to_use)
    [trAcRF, teAcRF, totAcRF] = runRF(newresponses, newmatrix, insert_decimal_for_how_much_training_to_use)
    results[0].append(trAcSVM)
    results[1].append(teAcSVM)
    results[2].append(totAcSVM)
    results[3].append(trAcRF)
    results[4].append(teAcRF)
    results[5].append(totAcRF)

    print(numpy.mean(results[0]))
    print(numpy.mean(results[1]))
    print(numpy.mean(results[2]))
    print(numpy.mean(results[3]))
    print(numpy.mean(results[4]))
    print(numpy.mean(results[5]))


	The 6 values printed, in order are the following: average SVM training accuracy, average SVM testing accuracy,
	average SVM overall accuracy, average Random Forest training accuracy, average Random Forest testing accuracy,
	and average Random Forest overall accuracy.



	e. Optional step: if you are doing classifications, there may be some issues when using small amounts of training
	data. For instance, the permutations may choose all 1s for training, which will cause an error (because there is
	only one class present). If you have more than two classes, the training data many not have a case of each class,
	so it won’t predict as accurately. You can put in some code to make sure the training data has all classes for each
	permutation.




2) Machine learning with some prior knowledge

This is identical to everything above. Run the same script, but for the variable “which,” you will want to set it as a
list of the indices of whichever genome variables you want to use.




3) SIM1 machine learning

IMPORTANT TO NOTE: currently, similarity scores are calculated for classifications, simply calculating how often two
genomes responded in the same way. Change there will have to be significant alterations to the code (particularly in
MatrixService, for the similarity calculation, and in ThirdPartyProgramCaller, to allow for vectors and such to be
outputs of simulations). I did use vector difference for some tests when calculating similarity. In MatrixService,
I put in the following code:

    for i in range(0, self.number_of_genomes-1):

        for j in range(i+1, self.number_of_genomes):

            trial_similarities=[]

            for k in valid_trial_list:

                trial_similarities.append(numpy.linalg.norm(numpy.asarray(response_matrix[i][k])-numpy.asarray(response_matrix[j][k])))

            score=1-(numpy.mean(trial_similarities)/insert_max_distance_between_vectors)	#COMMENT: similarity scores should be between 0 and 1. Scale appropriately.
            kernel[i][j]=score
            kernel[j][i]=score



After running SIM1, in the GenomeFiles folder, there should be a Sim1SimilarityMatrix.csv. This will be a very similar process to naive machine learning.

	a. Get the data from Sim0Output.csv into a list.
	
	b. Get the data from Sim1SimilarityMatrix.csv into a list of lists (like a matrix)

	c. Run a similar script to the one above, with a few changes. The script should look something like this:


    results=[[], [], []]

    for i in range(0, insert_number_of_desired_permutations_of_data):

        order = numpy.random.permutation(insert_number_of_genomes)
        newresponses = []

        for i in order:

            newresponses.append(response_list[i])

        newkernel = []

        for i in order:

            values = []

            for j in order:

                values.append(kernel[i][j])

            newkernel.append(values)

        [trAc, teAc, totAc] = runSVM(newresponses, newkernel, "precomputed", insert_decimal_for_how_much_training_to_use)
        results[0].append(trAc)
        results[1].append(teAc)
        results[2].append(totAc)

    print(numpy.mean(results[0]))
    print(numpy.mean(results[1]))
    print(numpy.mean(results[2]))

	
		The 3 values printed, in order are the following: average kernelized SVM training accuracy,
		average kernelized SVM testing accuracy, and average kernelized SVM overall accuracy.



	d. Optional step: the issues for classifications from naive machine learning (see step e) will still occur here, so
	make similar edits if you want to avoid this.
